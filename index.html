<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>REALLY BAD</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#2a241d;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    canvas{display:block}
    #hud{position:fixed;left:16px;top:14px;z-index:10;color:rgba(255,255,255,.92);text-shadow:0 1px 10px rgba(0,0,0,.55);pointer-events:none;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    #hud strong{letter-spacing:.14em;text-transform:uppercase}
    #hint,#status{font-size:12px;letter-spacing:.10em;text-transform:uppercase;opacity:.8}
    #overlay{position:fixed;inset:0;z-index:20;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at center,rgba(45,40,32,.20),rgba(22,20,18,.94));color:#fff;padding:24px}
    #overlay .card{max-width:760px;border:1px solid rgba(255,255,255,.12);background:rgba(40,34,26,.58);border-radius:18px;padding:18px 18px 14px;box-shadow:0 14px 44px rgba(0,0,0,.42);text-align:center}
    #overlay .title{font-size:16px;font-weight:900;margin-bottom:10px;letter-spacing:.12em;text-transform:uppercase}
    #overlay .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:10px}
    #overlay button,#overlay a{padding:12px 16px;border-radius:12px;border:1px solid rgba(255,255,255,.22);background:rgba(255,255,255,.10);color:#fff;cursor:pointer;font-weight:900;letter-spacing:.10em;text-transform:uppercase;text-decoration:none;display:inline-flex;align-items:center;justify-content:center}
    #overlay button:hover,#overlay a:hover{background:rgba(255,255,255,.14)}
    #enterMsg{display:none;opacity:.95;font-size:12px;letter-spacing:.08em;text-transform:uppercase;margin-top:10px;line-height:1.35;color:rgba(255,240,240,.95)}

    #cpOverlay{position:fixed;inset:0;z-index:30;display:none;align-items:center;justify-content:center;background:radial-gradient(circle at center,rgba(45,40,32,.18),rgba(20,18,16,.96));color:#fff;padding:24px}
    #cpOverlay .card{width:min(820px,96vw);border:1px solid rgba(255,255,255,.12);background:rgba(40,34,26,.58);border-radius:18px;padding:16px;box-shadow:0 14px 44px rgba(0,0,0,.42);text-align:center}
    #cpOverlay .title{font-weight:900;letter-spacing:.16em;text-transform:uppercase;margin-bottom:10px}
    #cpOverlay .sub{opacity:.85;font-size:13px;letter-spacing:.08em;text-transform:uppercase;margin-bottom:14px;line-height:1.35}
    #cpOverlay input{width:min(420px,92vw);padding:12px 14px;border-radius:12px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08);color:rgba(255,255,255,.95);outline:none;font-size:16px;letter-spacing:.06em;text-align:center}
    #cpOverlay .actions{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:12px}
    #cpOverlay button{padding:12px 16px;border-radius:12px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.10);color:#fff;cursor:pointer;font-weight:900;letter-spacing:.10em;text-transform:uppercase}
    #cpOverlay button.primary{background:rgba(255,255,255,.14)}
    #cpOverlay .err{margin-top:10px;opacity:.9;font-size:12px;letter-spacing:.08em;text-transform:uppercase;color:rgba(255,220,220,.95);display:none}
  </style>
</head>
<body>
  <div id="hud">
    <div><strong>REALLY BAD</strong></div>
    <div id="hint">WASD • SHIFT (SPRINT) • MOUSE • ENTER (ELEVATOR DOORS) • C TOGGLE (ELEVATOR) • CTRL HOLD (ELEVATOR) • F (DOOR) • E (EXIT)</div>
    <div id="status"></div>
  </div>

  <div id="overlay">
    <div class="card">
      <div class="title">Welcome To Floor 7 1/2 At The Mertin Flemmer Building</div>
      <div class="row">
        <button id="enter">ENTER</button>
        <a href="https://reallybadband.komi.io" target="_blank" rel="noopener noreferrer">MUSIC &amp; VIDEOS</a>
      </div>
      <div id="enterMsg"></div>
    </div>
  </div>

  <div id="cpOverlay" aria-hidden="true">
    <div class="card">
      <div class="title">JOIN THE COUNTER PROGRAM</div>
      <div class="sub">(ENTER YOUR PHONE NUMBER)</div>
      <div><input id="phone" inputmode="tel" autocomplete="tel" placeholder="PHONE NUMBER" /></div>
      <div class="actions" id="cpActions">
        <button id="submitPhone" class="primary">SUBMIT</button>
        <button id="cpCancel">CANCEL</button>
      </div>
      <div class="actions" id="afterJoin" style="display:none;">
        <button id="explore" class="primary">EXPLORE</button>
        <button id="listen">LISTEN</button>
      </div>
      <div class="err" id="cpErr"></div>
    </div>
  </div>

  <!-- Bootstrap: always runs -->
  <script>
    (function(){
      const statusEl = document.getElementById('status');
      const overlay = document.getElementById('overlay');
      const enterBtn = document.getElementById('enter');
      const msg = document.getElementById('enterMsg');
      if (statusEl) statusEl.textContent = 'BOOT';

      window.addEventListener('error', (e)=>{
        try{ console.error(e.error||e.message||e); }catch{}
        if (statusEl) statusEl.textContent = 'BOOT ERROR';
        if (msg){ msg.style.display='block'; msg.textContent='SCRIPT ERROR. OPEN DEVTOOLS → CONSOLE (FIRST RED LINE).'; }
      });

      function runEnter(){
        if (typeof window.__rbEnter === 'function') window.__rbEnter();
        else if (msg){ msg.style.display='block'; msg.textContent='3D NOT READY YET. WAIT 2s THEN CLICK ENTER AGAIN.'; }
      }
      enterBtn.addEventListener('click', (e)=>{ e.preventDefault(); runEnter(); });
      window.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && overlay.style.display!=='none'){ e.preventDefault(); runEnter(); } });
    })();
  </script>

  <!-- Three.js with fallback -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js'"></script>

  <script>
  (function(){
    const statusEl = document.getElementById('status');
    const overlay = document.getElementById('overlay');
    const enterMsg = document.getElementById('enterMsg');
    if (!window.THREE){
      if (statusEl) statusEl.textContent = 'THREE FAILED TO LOAD';
      if (enterMsg){ enterMsg.style.display='block'; enterMsg.textContent='THREE.JS FAILED TO LOAD (CDN BLOCKED).'; }
      return;
    }

    // ---- Config ----
    const ACCENT = 0xdc4d3c;
    const CEIL_H = 1.85;            // low ceiling everywhere
    const STAND_Y = 1.02;
    const CROUCH_Y = 0.56;
    const PLAYER_R = 0.38;
    let PLAYER_HALF_H = 0.25;

    const WALK = 3.0;
    const SPRINT = 15.0;  // Updated from 8.5
    const ACCEL = 18.0;
    const DAMP = 11.0;
    
    const CORRIDOR_OPENING_W = 4.6; // Width of openings between rooms
    const BOUNDS_X_MIN = -22;
    const BOUNDS_X_MAX = 22;
    const BOUNDS_Z_MIN = -28;
    const BOUNDS_Z_MAX = 150; // Extended to allow chamber exploration

    const ELEV = { x:0, z:-19.5, w:2.05, d:1.70 };
    const ORIENT = { x:0, z:5, w:30, d:14 }; // Orientation Room (replaces LOBBY)
    const HALL = { len:96, w:6.2, doors:10 };
    const HALL_X = { COMPLIANCE:-10, SURVEILLANCE:0, PURSUANCE:10 };

    // persistence
    const url = new URLSearchParams(location.search);
    if (url.has('reset')){ localStorage.removeItem('rb_completed'); sessionStorage.removeItem('rb_disable_cp'); sessionStorage.removeItem('rb_explore_only'); }
    const exploreOnly = url.has('explore') || sessionStorage.getItem('rb_explore_only')==='1';
    const cpDisabled = sessionStorage.getItem('rb_disable_cp')==='1';

    const completed = new Set(JSON.parse(localStorage.getItem('rb_completed')||'[]'));
    const saveCompletion = ()=>localStorage.setItem('rb_completed', JSON.stringify([...completed]));
    const allComplete = ()=>completed.has('SURVEILLANCE') && completed.has('COMPLIANCE') && completed.has('PURSUANCE');

    // ---- Scene ----
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x2a241d);
    scene.fog = new THREE.FogExp2(0x2a241d, 0.012);

    const camera = new THREE.PerspectiveCamera(78, innerWidth/innerHeight, 0.1, 420);

    const renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.74;
    document.body.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xfff3d1, 0.22);
    scene.add(ambient);
    const hemi = new THREE.HemisphereLight(0xffffff, 0x3a3327, 0.18);
    hemi.position.set(0,50,0);
    scene.add(hemi);

    const world = new THREE.Group();
    scene.add(world);

    // ---- Simple materials (keep this rewrite compact) ----
    const mat = {
      offWhite: new THREE.MeshStandardMaterial({ color:0xe7e1d3, roughness:0.98, metalness:0.0 }),
      ceiling:  new THREE.MeshStandardMaterial({ color:0xf1ebdd, roughness:0.98, metalness:0.0 }),
      charcoal: new THREE.MeshStandardMaterial({ color:0x5e5a54, roughness:0.98, metalness:0.0 }),
      green:    new THREE.MeshStandardMaterial({ color:0x2f3b32, roughness:0.98, metalness:0.0 }),
      navy:     new THREE.MeshStandardMaterial({ color:0x243245, roughness:0.98, metalness:0.0 }),
      trim:     new THREE.MeshStandardMaterial({ color:0xb7ad9d, roughness:0.95, metalness:0.0 }),
      accent:   new THREE.MeshStandardMaterial({ color:ACCENT, roughness:0.7, metalness:0.0 }),
      elevWall: new THREE.MeshStandardMaterial({ color:0xa7a39b, roughness:0.55, metalness:0.12 }),
      elevTrim: new THREE.MeshStandardMaterial({ color:0x8d887f, roughness:0.42, metalness:0.35 }),
      wood:     new THREE.MeshStandardMaterial({ color:0x5a3a22, roughness:0.86, metalness:0.02 }),
      steel:    new THREE.MeshStandardMaterial({ color:0xcfc9bf, roughness:0.28, metalness:0.68 }),
      door:     new THREE.MeshStandardMaterial({ color:0x8d887f, roughness:0.55, metalness:0.15 }),
      glass:    new THREE.MeshStandardMaterial({ color:0x0b0c0d, transparent:true, opacity:0.10, roughness:0.2, metalness:0.0 })
    };

    // Reduce z-fighting on coplanar elevator door surfaces
    mat.door.polygonOffset = true;
    // stronger offset to eliminate z-fighting shimmer against trim/frames
    mat.door.polygonOffsetFactor = -3;
    mat.door.polygonOffsetUnits = -3;

    // ---- Collisions (bucketed AABBs) ----
    const BUCKET = 12;
    const buckets = new Map();
    const bucketKey = (ix,iz)=>ix+','+iz;

    function addColliderBox(box){
      const obj={ box, active:true };
      const minI=Math.floor(box.min.x/BUCKET), maxI=Math.floor(box.max.x/BUCKET);
      const minK=Math.floor(box.min.z/BUCKET), maxK=Math.floor(box.max.z/BUCKET);
      for(let ix=minI;ix<=maxI;ix++) for(let iz=minK;iz<=maxK;iz++){
        const key=bucketKey(ix,iz);
        if(!buckets.has(key)) buckets.set(key,[]);
        buckets.get(key).push(obj);
      }
      return obj;
    }

    function addCollider(mesh){
      const box=new THREE.Box3().setFromObject(mesh);
      return addColliderBox(box);
    }

    function nearby(px,pz){
      const ix=Math.floor(px/BUCKET), iz=Math.floor(pz/BUCKET);
      const out=[];
      for(let dx=-1;dx<=1;dx++) for(let dz=-1;dz<=1;dz++){
        const arr=buckets.get(bucketKey(ix+dx,iz+dz));
        if(arr) out.push(...arr);
      }
      return out;
    }

    function collides(px,py,pz){
      const yMin=py-PLAYER_HALF_H, yMax=py+PLAYER_HALF_H;
      for(const obj of nearby(px,pz)){
        if(!obj.active) continue;
        const b=obj.box;
        if(px>=(b.min.x-PLAYER_R)&&px<=(b.max.x+PLAYER_R)&&pz>=(b.min.z-PLAYER_R)&&pz<=(b.max.z+PLAYER_R)&&yMax>=b.min.y&&yMin<=b.max.y) return true;
      }
      return false;
    }

    const WALL_T = 0.14;

    function wallBox(cx,cy,cz,sx,sy,sz,m,coll=true){
      const mesh=new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz),m);
      mesh.position.set(cx,cy,cz);
      world.add(mesh);
      if(coll) addCollider(mesh);
      return mesh;
    }

    function floorPlane(x,z,w,d,m){
      const f=new THREE.Mesh(new THREE.PlaneGeometry(w,d),m);
      f.rotation.x=-Math.PI/2;
      f.position.set(x,0,z);
      world.add(f);
    }

    function ceilPlane(x,z,w,d,h,m){
      const c=new THREE.Mesh(new THREE.PlaneGeometry(w,d),m);
      c.rotation.x=Math.PI/2;
      c.position.set(x,h,z);
      world.add(c);
    }

    // ---- Sign textures (simple canvas) ----
    function plaqueTex(text){
      const c=document.createElement('canvas'); c.width=512; c.height=192;
      const g=c.getContext('2d');
      g.fillStyle='rgba(244,238,223,1)'; g.fillRect(0,0,c.width,c.height);
      g.strokeStyle='rgba(0,0,0,.12)'; g.lineWidth=6; g.strokeRect(14,14,c.width-28,c.height-28);
      g.fillStyle='rgba(43,38,32,0.92)';
      g.font='900 44px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
      g.textAlign='center'; g.textBaseline='middle';
      g.fillText(text, c.width/2, c.height/2);
      const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; t.needsUpdate=true;
      return t;
    }

    function addHeaderSign(text,x,z){
      const tex=plaqueTex(text);
      const face=new THREE.Mesh(new THREE.PlaneGeometry(4.0,0.34), new THREE.MeshStandardMaterial({ map:tex, roughness:0.65, metalness:0.0 }));
      face.position.set(x,1.40,z);
      face.rotation.y=Math.PI;
      world.add(face);
      const bar=new THREE.Mesh(new THREE.BoxGeometry(4.6,0.12,0.22), mat.trim);
      bar.position.set(x,1.62,z+0.18);
      world.add(bar);
      const acc=new THREE.Mesh(new THREE.BoxGeometry(4.6,0.05,0.08), mat.accent);
      acc.position.set(x,1.70,z+0.18);
      world.add(acc);
    }

    // ---- Elevator ----
    const elevArea = new THREE.Box3(
      new THREE.Vector3(ELEV.x-ELEV.w/2+0.06, 0, ELEV.z-ELEV.d/2+0.06),
      new THREE.Vector3(ELEV.x+ELEV.w/2-0.06, 2.2, ELEV.z+ELEV.d/2-0.06)
    );
    const isInElevator = (pos)=>elevArea.containsPoint(pos);

    const elev={ open:false, t:0, left:null, right:null, leftColl:null, rightColl:null, floor7:null, floor8:null };

    function buildElevator(){
      // base box
      floorPlane(ELEV.x,ELEV.z,ELEV.w,ELEV.d, mat.charcoal);
      ceilPlane(ELEV.x,ELEV.z,ELEV.w,ELEV.d, CEIL_H, mat.ceiling);
      const cy=CEIL_H/2;
      wallBox(ELEV.x,cy,ELEV.z-ELEV.d/2, ELEV.w, CEIL_H, WALL_T, mat.elevWall);
      wallBox(ELEV.x-ELEV.w/2,cy,ELEV.z, WALL_T, CEIL_H, ELEV.d, mat.elevWall);
      wallBox(ELEV.x+ELEV.w/2,cy,ELEV.z, WALL_T, CEIL_H, ELEV.d, mat.elevWall);

      const southZ=ELEV.z+ELEV.d/2;
      const hatchW=1.55;
      const hatchH=1.70;

      // south wall with opening
      const leftLen=(ELEV.x-hatchW/2)-(ELEV.x-ELEV.w/2);
      if(leftLen>0.05) wallBox((ELEV.x-ELEV.w/2)+leftLen/2,cy,southZ, leftLen, CEIL_H, WALL_T, mat.elevWall);
      const rightLen=(ELEV.x+ELEV.w/2)-(ELEV.x+hatchW/2);
      if(rightLen>0.05) wallBox((ELEV.x+hatchW/2)+rightLen/2,cy,southZ, rightLen, CEIL_H, WALL_T, mat.elevWall);
      // above hatch

      // wood panels
      const panelH=1.55, panelY=0.78, inset=0.06;
      const backPanel=new THREE.Mesh(new THREE.BoxGeometry(ELEV.w-0.14,panelH,0.04), mat.wood);
      backPanel.position.set(ELEV.x,panelY,ELEV.z-ELEV.d/2+inset);
      world.add(backPanel);
      const leftPanel=new THREE.Mesh(new THREE.BoxGeometry(0.04,panelH,ELEV.d-0.14), mat.wood);
      leftPanel.position.set(ELEV.x-ELEV.w/2+inset,panelY,ELEV.z);
      world.add(leftPanel);
      const rightPanel=new THREE.Mesh(new THREE.BoxGeometry(0.04,panelH,ELEV.d-0.14), mat.wood);
      rightPanel.position.set(ELEV.x+ELEV.w/2-inset,panelY,ELEV.z);
      world.add(rightPanel);

      // rails
      const railLen=ELEV.d-0.55;
      const railBack=new THREE.Mesh(new THREE.BoxGeometry(ELEV.w-0.55,0.06,0.06), mat.steel);
      railBack.position.set(ELEV.x,0.92,ELEV.z-ELEV.d/2+0.22);
      world.add(railBack);
      const railL=new THREE.Mesh(new THREE.BoxGeometry(0.06,0.06,railLen), mat.steel);
      railL.position.set(ELEV.x-ELEV.w/2+0.22,0.92,ELEV.z);
      world.add(railL);
      const railR=new THREE.Mesh(new THREE.BoxGeometry(0.06,0.06,railLen), mat.steel);
      railR.position.set(ELEV.x+ELEV.w/2-0.22,0.92,ELEV.z);
      world.add(railR);

      // ceiling light
      const panel=new THREE.Mesh(new THREE.BoxGeometry(ELEV.w-0.55,0.04,ELEV.d-0.75), new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.25, metalness:0.0, emissive:0xffffff, emissiveIntensity:0.12 }));
      panel.position.set(ELEV.x,CEIL_H-0.10,ELEV.z);
      world.add(panel);
      const light=new THREE.PointLight(0xffffff,0.30,10,1.6);
      light.position.set(ELEV.x,CEIL_H-0.35,ELEV.z);
      scene.add(light);

      // indicator bar: 11 circles, 7 + 8 flicker (animated)
      const indCanvas = document.createElement('canvas');
      indCanvas.width = 1024; indCanvas.height = 180;
      const indCtx = indCanvas.getContext('2d');
      const indTex = new THREE.CanvasTexture(indCanvas);
      indTex.colorSpace = THREE.SRGBColorSpace;
      indTex.needsUpdate = true;

      elev.drawIndicator = function(timeMs){
        const g = indCtx;
        const w = indCanvas.width, h = indCanvas.height;
        g.clearRect(0,0,w,h);

        // dark metal plate
        g.fillStyle = 'rgba(18,16,14,0.92)';
        g.fillRect(0,0,w,h);
        g.strokeStyle = 'rgba(255,255,255,0.14)';
        g.lineWidth = 10;
        g.strokeRect(12,12,w-24,h-24);

        const floors = 11;
        const pad = 84;
        const step = (w - pad*2) / floors;

        // flicker for 7 and 8
        const t = timeMs * 0.001;
        const flick7 = 0.55 + 0.45*Math.max(0, Math.sin(t*18.0));
        const flick8 = 0.55 + 0.45*Math.max(0, Math.sin((t+0.18)*16.0));

        for(let i=1;i<=floors;i++){
          const cx = pad + (i-0.5)*step;
          const cy = 92;
          const r  = 20;
          const is78 = (i===7 || i===8);
          const litA = (i===7)?flick7:((i===8)?flick8:0.0);

          g.beginPath();
          g.arc(cx,cy,r,0,Math.PI*2);
          g.fillStyle = is78 ? `rgba(247,178,74,${0.92*litA})` : 'rgba(255,255,255,0.10)';
          g.fill();
          g.lineWidth = 6;
          g.strokeStyle = is78 ? 'rgba(255,255,255,0.22)' : 'rgba(255,255,255,0.12)';
          g.stroke();

          g.fillStyle = is78 ? 'rgba(18,16,14,0.92)' : 'rgba(255,255,255,0.74)';
          g.font = '900 22px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
          g.textAlign = 'center';
          g.textBaseline = 'middle';
          g.fillText(String(i), cx, cy+1);
        }

        indTex.needsUpdate = true;
      };

      // initial draw
      elev.drawIndicator(Date.now());

      const indMat = new THREE.MeshStandardMaterial({
        map: indTex,
        roughness: 0.35,
        metalness: 0.25,
        emissive: new THREE.Color(0xffffff),
        emissiveIntensity: 0.35,
        toneMapped: false
      });

      // Wood backer panel for the indicator (integrates it into the elevator interior)
      const indBack = new THREE.Mesh(
        new THREE.BoxGeometry(1.78, 0.34, 0.06),
        mat.wood
      );
      indBack.position.set(ELEV.x, 1.70, southZ - 0.18);
      indBack.rotation.y = Math.PI;
      world.add(indBack);

      // Smaller indicator face mounted on the wood panel
      const ind = new THREE.Mesh(new THREE.PlaneGeometry(1.55, 0.26), indMat);
      ind.position.set(ELEV.x, 1.70, southZ - 0.148);
      ind.rotation.y = Math.PI;
      ind.renderOrder = 6;
      world.add(ind);

      // Thin trim strip above the wood panel (subtle hardware detail)
      const indTrim = new THREE.Mesh(
        new THREE.BoxGeometry(1.88, 0.06, 0.08),
        mat.elevTrim
      );
      indTrim.position.set(ELEV.x, 1.88, southZ - 0.18);
      indTrim.rotation.y = Math.PI;
      world.add(indTrim);

      // sliding doors
      const elevDoorH=hatchH-0.10, elevDoorY=elevDoorH/2+0.04, elevDoorT=0.06;
      const leftD=new THREE.Mesh(new THREE.BoxGeometry(hatchW/2,elevDoorH,elevDoorT), mat.door);
      // pull doors further off the wall plane and lift slightly to avoid floor-edge fighting
      leftD.position.set(ELEV.x-hatchW/4, elevDoorY + 0.01, southZ-0.11);
      world.add(leftD);
      const rightD=new THREE.Mesh(new THREE.BoxGeometry(hatchW/2,elevDoorH,elevDoorT), mat.door);
      // pull doors further off the wall plane and lift slightly to avoid floor-edge fighting
      rightD.position.set(ELEV.x+hatchW/4, elevDoorY + 0.01, southZ-0.11);
      world.add(rightD);
      elev.left=leftD; elev.right=rightD;
      elev.leftColl=addCollider(leftD);
      elev.rightColl=addCollider(rightD);

      // Door threshold/track (visual only) to hide bottom-edge shimmer artifacts
      const threshold = new THREE.Mesh(
        new THREE.BoxGeometry(hatchW + 0.18, 0.08, 0.16),
        mat.elevTrim
      );
      threshold.position.set(ELEV.x, 0.04, southZ - 0.095);
      world.add(threshold);

      // (removed window panel above the door opening)

      // --- 8th floor platform (the "between floors" slab)
      // This slab represents the 8th-floor edge ABOVE you.
      // It should block standing-height movement, but allow crouching underneath to reach 7 1/2.
      const f8Y = 1.06;           // top surface height (crouch passes under; standing collides)
      const f8W = 4.20;
      const f8D = 6.20;
      const f8T = 0.18;
      const f8NearEdgeZ = southZ + 0.38;              // near edge is just beyond the doors
      const f8CenterZ = f8NearEdgeZ + f8D / 2;

      const f8Platform = new THREE.Mesh(new THREE.BoxGeometry(f8W, f8T, f8D), mat.offWhite);
      f8Platform.position.set(ELEV.x, f8Y - f8T / 2, f8CenterZ);
      world.add(f8Platform);
      addCollider(f8Platform);


      // The "8" should live ON the 8th floor (decal on the platform), small like the film reference
      const eightC = document.createElement('canvas');
      eightC.width = 512; eightC.height = 512;
      const g8 = eightC.getContext('2d');
      g8.fillStyle = 'rgb(225,220,210)';
      g8.fillRect(0, 0, 512, 512);
      g8.fillStyle = 'rgba(18,16,14,0.92)';
      g8.font = '900 300px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
      g8.textAlign = 'center';
      g8.textBaseline = 'middle';
      g8.fillText('8', 256, 286);
      const eightT = new THREE.CanvasTexture(eightC);
      eightT.colorSpace = THREE.SRGBColorSpace;
      eightT.needsUpdate = true;

      const eightMat = new THREE.MeshStandardMaterial({ map: eightT, roughness: 0.92, metalness: 0.0 });
      // Prevent shimmer on the decal by biasing depth
      eightMat.polygonOffset = true;
      eightMat.polygonOffsetFactor = -2;
      eightMat.polygonOffsetUnits = -2;

      // Small "8" decal ON the 8th-floor slab (subtle, like the film reference)
      const eightDecal = new THREE.Mesh(new THREE.PlaneGeometry(0.42, 0.42), eightMat);
      eightDecal.rotation.x = -Math.PI / 2;
      eightDecal.position.set(ELEV.x, f8Y + 0.008, f8NearEdgeZ + 2.35);
      eightDecal.renderOrder = 7;
      world.add(eightDecal);

      // --- 8th floor "lobby" vignette (no collisions; just something to see beyond)
      const lobbyW = 7.2;
      const lobbyD = 7.8;
      const lobbyH = 2.25;
      const lobbyX = ELEV.x;

      // IMPORTANT: place lobby floor beyond the floor-8 slab to avoid z-fighting shimmer
      const lobbyNearZ = f8NearEdgeZ + f8D + 0.10;
      const lobbyZ = lobbyNearZ + lobbyD / 2;

      // lobby floor plane at the 8th-floor height (visual only)
      const lobbyFloor = new THREE.Mesh(new THREE.PlaneGeometry(lobbyW, lobbyD), mat.offWhite);
      lobbyFloor.rotation.x = -Math.PI / 2;
      lobbyFloor.position.set(lobbyX, f8Y + 0.024, lobbyZ);
      world.add(lobbyFloor);

      // lobby ceiling + soft light
      const lobbyCeil = new THREE.Mesh(new THREE.PlaneGeometry(lobbyW, lobbyD), mat.ceiling);
      lobbyCeil.rotation.x = Math.PI / 2;
      lobbyCeil.position.set(lobbyX, f8Y + lobbyH, lobbyZ);
      world.add(lobbyCeil);

      const lobbyLightPanel = new THREE.Mesh(
        new THREE.BoxGeometry(2.8, 0.05, 1.05),
        new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.25, metalness: 0.0, emissive: 0xffffff, emissiveIntensity: 0.20 })
      );
      lobbyLightPanel.position.set(lobbyX, f8Y + lobbyH - 0.10, lobbyZ);
      world.add(lobbyLightPanel);

      const lobbyLight = new THREE.PointLight(0xffffff, 0.28, 16, 1.6);
      lobbyLight.position.set(lobbyX, f8Y + lobbyH - 0.40, lobbyZ);
      scene.add(lobbyLight);

      // back wall + side walls (visual only)
      wallBox(lobbyX, f8Y + lobbyH / 2, lobbyZ + lobbyD / 2, lobbyW, lobbyH, WALL_T, mat.offWhite, false);
      wallBox(lobbyX - lobbyW / 2, f8Y + lobbyH / 2, lobbyZ, WALL_T, lobbyH, lobbyD, mat.offWhite, false);
      wallBox(lobbyX + lobbyW / 2, f8Y + lobbyH / 2, lobbyZ, WALL_T, lobbyH, lobbyD, mat.offWhite, false);

      // reception desk + seating (push FAR left + DEEP so it never blocks the doorway view)
      const deskX = lobbyX - 2.85;
      const deskZ = lobbyNearZ + 5.55;

      const deskTop = new THREE.Mesh(new THREE.BoxGeometry(2.35, 0.10, 0.85), mat.wood);
      deskTop.position.set(deskX, f8Y + 0.56, deskZ);
      world.add(deskTop);

      const deskBody = new THREE.Mesh(new THREE.BoxGeometry(2.35, 0.50, 0.68), mat.wood);
      deskBody.position.set(deskX, f8Y + 0.25, deskZ + 0.05);
      world.add(deskBody);

      // simple chairs (keep them off-axis so they don't form a bar across the doorway)
      function addChair(cx, cz){
        const seat = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.08, 0.55), mat.trim);
        seat.position.set(cx, f8Y + 0.32, cz);
        world.add(seat);
        const back = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.55, 0.08), mat.trim);
        back.position.set(cx, f8Y + 0.62, cz - 0.24);
        world.add(back);
        const legMat = mat.elevTrim;
        const leg1 = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.30, 0.06), legMat);
        const leg2 = leg1.clone();
        const leg3 = leg1.clone();
        const leg4 = leg1.clone();
        leg1.position.set(cx - 0.22, f8Y + 0.15, cz - 0.22);
        leg2.position.set(cx + 0.22, f8Y + 0.15, cz - 0.22);
        leg3.position.set(cx - 0.22, f8Y + 0.15, cz + 0.22);
        leg4.position.set(cx + 0.22, f8Y + 0.15, cz + 0.22);
        world.add(leg1, leg2, leg3, leg4);
      }

      // desk-side chairs (behind desk)
      addChair(deskX + 0.80, deskZ - 0.85);
      addChair(deskX + 1.60, deskZ - 0.85);

      // waiting area (deep + right side so it reads as background detail)
      addChair(lobbyX + 2.05, lobbyNearZ + 6.05);
      addChair(lobbyX + 2.85, lobbyNearZ + 6.05);
      const table = new THREE.Mesh(new THREE.BoxGeometry(0.90, 0.10, 0.55), mat.trim);
      table.position.set(lobbyX + 2.45, f8Y + 0.30, lobbyNearZ + 6.65);
      world.add(table);

      // a subtle back accent strip to give depth
      const backTrim = new THREE.Mesh(new THREE.BoxGeometry(lobbyW - 0.40, 0.10, 0.18), mat.trim);
      backTrim.position.set(lobbyX, f8Y + 0.95, lobbyZ + lobbyD / 2 - 0.08);
      world.add(backTrim);

    }

    // ---- Lobby + corridor + hallways ----
    const doors=[]; // hallway doors: { mesh, colliderObj, open }
    const raycaster=new THREE.Raycaster();

    function addDoor(x,z,rotY,doorMat){
      const doorW=1.05, doorH=1.55, doorT=0.08;
      const d=new THREE.Mesh(new THREE.BoxGeometry(doorW,doorH,doorT), doorMat);
      d.position.set(x,doorH/2,z);
      d.rotation.y=rotY;
      world.add(d);
      const col=addCollider(d);
      doors.push({ mesh:d, colliderObj:col, open:false });
      return d;
    }

    function lookDoor(maxDist=2.2){
      const dir=new THREE.Vector3(); camera.getWorldDirection(dir);
      raycaster.set(camera.position,dir); raycaster.far=maxDist;
      const hits=raycaster.intersectObjects(doors.map(o=>o.mesh),false);
      if(!hits.length) return null;
      const obj=hits[0].object;
      return doors.find(o=>o.mesh===obj)||null;
    }

    function toggleDoor(d){
      d.open=!d.open;
      d.colliderObj.active=!d.open;
      const dir=new THREE.Vector3(Math.sin(d.mesh.rotation.y),0,Math.cos(d.mesh.rotation.y));
      if(d.open) d.mesh.position.addScaledVector(dir,0.70);
      else d.mesh.position.addScaledVector(dir,-0.70);
    }

    function buildOrientationRoom(centerZ = ORIENT.z, withFloor = true, withCeiling = true, isMainRoom = true){
      // Orientation room spans ORIENT.d units (z = centerZ-ORIENT.d/2 to centerZ+ORIENT.d/2)
      const halfDepth = ORIENT.d/2;
      const startZ = centerZ - halfDepth;
      const endZ = centerZ + halfDepth;
      
      // Floor and ceiling
      if (withFloor) {
        floorPlane(ORIENT.x, centerZ, ORIENT.w, ORIENT.d, mat.offWhite);
      }
      if (withCeiling) {
        ceilPlane(ORIENT.x, centerZ, ORIENT.w, ORIENT.d, CEIL_H, mat.ceiling);
      }
      
      const cy = CEIL_H/2;
      
      // Side walls
      wallBox(-ORIENT.w/2, cy, centerZ, WALL_T, CEIL_H, ORIENT.d, mat.offWhite);
      wallBox(ORIENT.w/2, cy, centerZ, WALL_T, CEIL_H, ORIENT.d, mat.offWhite);
      
      // South wall (entrance) - main room has opening from transition corridor, copies are open for hallway
      if (isMainRoom) {
        // Opening for transition corridor (centered, same width as corridor)
        const openingW = CORRIDOR_OPENING_W;
        const leftLen = (-openingW/2) - (-ORIENT.w/2);
        if (leftLen > 0.25) wallBox((-ORIENT.w/2) + leftLen/2, cy, startZ, leftLen, CEIL_H, WALL_T, mat.offWhite);
        const rightLen = (ORIENT.w/2) - (openingW/2);
        if (rightLen > 0.25) wallBox((openingW/2) + rightLen/2, cy, startZ, rightLen, CEIL_H, WALL_T, mat.offWhite);
      }
      // For copies at hallway ends, no south wall (hallway connects directly)
      
      // North wall with 3 openings for C, S, P hallways
      const northZ = endZ;
      const openingW = CORRIDOR_OPENING_W;
      const spans = [HALL_X.COMPLIANCE, HALL_X.SURVEILLANCE, HALL_X.PURSUANCE]
        .map(x => ({a: x - openingW/2, b: x + openingW/2}))
        .sort((p, q) => p.a - q.a);
      
      let cur = -ORIENT.w/2;
      for (const s of spans) {
        const seg = s.a - cur;
        if (seg > 0.25) wallBox(cur + seg/2, cy, northZ, seg, CEIL_H, WALL_T, mat.offWhite);
        cur = s.b;
      }
      const tail = (ORIENT.w/2) - cur;
      if (tail > 0.25) wallBox(cur + tail/2, cy, northZ, tail, CEIL_H, WALL_T, mat.offWhite);
      
      // Lighting
      for (let i = 0; i < 4; i++) {
        const z = startZ + 2 + i * 3;
        const panel = new THREE.Mesh(
          new THREE.BoxGeometry(3.2, 0.05, 0.95),
          new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.25,
            metalness: 0.0,
            emissive: 0xffffff,
            emissiveIntensity: 0.22
          })
        );
        panel.position.set(0, CEIL_H - 0.16, z);
        world.add(panel);
        
        const l = new THREE.PointLight(0xffffff, 0.28, 22, 1.35);
        l.position.set(0, CEIL_H - 0.44, z);
        scene.add(l);
      }
      
      // Department signage on north wall
      addHeaderSign('COMPLIANCE', HALL_X.COMPLIANCE, northZ - 0.24);
      addHeaderSign('SURVEILLANCE', HALL_X.SURVEILLANCE, northZ - 0.24);
      addHeaderSign('PURSUANCE', HALL_X.PURSUANCE, northZ - 0.24);
    }
    
    function buildElevatorTransition(){
      // Small corridor connecting elevator to orientation room
      const corridorZ = -5; // Between elevator exit and orientation room
      const corridorW = 4.4;
      const corridorD = 6; // From z=-8 to z=-2
      const cy = CEIL_H/2;
      
      floorPlane(0, corridorZ, corridorW, corridorD, mat.offWhite);
      ceilPlane(0, corridorZ, corridorW, corridorD, CEIL_H, mat.ceiling);
      wallBox(-corridorW/2, cy, corridorZ, WALL_T, CEIL_H, corridorD, mat.offWhite);
      wallBox(corridorW/2, cy, corridorZ, WALL_T, CEIL_H, corridorD, mat.offWhite);
    }

    const deptList=[
      { key:'COMPLIANCE', floor:mat.green, door:mat.green, subs:['POLITICAL PARTIES','FENTANYL','PORNOGRAPHY','CREDIT CARDS','SOCIAL MEDIA','DEBT','ALGORITHMS','DISTRACTIONS','FEAR CYCLES','THE FORMS ROOM'] },
      { key:'SURVEILLANCE', floor:mat.charcoal, door:mat.charcoal, subs:['PHONES','SMARTWATCHES','SMART GLASSES','TELEVISIONS','KITCHEN DEVICES','SEARCH HISTORY','BANKS','CAMERAS','DATA BROKERS','SATELLITES'] },
      { key:'PURSUANCE', floor:mat.navy, door:mat.navy, subs:['ADVERTISING','PHARMACEUTICAL','AG-BIOTECH','CHEM TRAILS','SPACE EXPLORATION','INFLUENCERS','PSYOPS','SIGNALS','NARRATIVES','DONKEYS & ELEPHANTS'] }
    ];

    const hallwayInfo=[];

    function buildHallway(dept){
      const hallX = HALL_X[dept.key];
      const startZ = ORIENT.z + ORIENT.d/2; // Start at north wall of orientation room
      const endZ = startZ + HALL.len;
      
      // floor/ceil
      floorPlane(hallX, startZ + HALL.len/2, HALL.w, HALL.len + 0.4, dept.floor);
      ceilPlane(hallX, startZ + HALL.len/2, HALL.w, HALL.len + 0.4, CEIL_H, mat.ceiling);
      const cy = CEIL_H/2;
      
      // walls - NO end wall to allow walking into orientation room copy or chamber
      wallBox(hallX - HALL.w/2, cy, startZ + HALL.len/2, WALL_T, CEIL_H, HALL.len + 0.4, mat.offWhite);
      wallBox(hallX + HALL.w/2, cy, startZ + HALL.len/2, WALL_T, CEIL_H, HALL.len + 0.4, mat.offWhite);

      // lights
      for (let i = 0; i < 9; i++) {
        const t = i/8;
        const z = startZ + 6 + t * (HALL.len - 12);
        const p = new THREE.Mesh(
          new THREE.BoxGeometry(2.6, 0.05, 0.72),
          new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.25,
            metalness: 0.0,
            emissive: 0xffffff,
            emissiveIntensity: 0.24
          })
        );
        p.position.set(hallX, CEIL_H - 0.16, z);
        world.add(p);
        const l = new THREE.PointLight(0xffffff, 0.30, 24, 1.35);
        l.position.set(hallX, CEIL_H - 0.46, z);
        scene.add(l);
      }

      // doors (staggered)
      const usable = HALL.len - 3.0;
      const step = usable/(HALL.doors + 1);
      for (let i = 0; i < HALL.doors; i++) {
        const z = startZ + 7.5 + (i + 1) * step;
        const side = (i % 2 === 0) ? -1 : 1;
        const wallX = hallX + side * (HALL.w/2);
        const doorX = wallX - side * 0.10;
        const rotY = (side === -1) ? Math.PI/2 : -Math.PI/2;

        // frame
        const frame = new THREE.Mesh(new THREE.BoxGeometry(1.25, 1.62, 0.10), mat.trim);
        frame.position.set(doorX, 0.81, z);
        frame.rotation.y = rotY;
        world.add(frame);

        addDoor(doorX - side * 0.06, z, rotY, dept.door);

        // plaque
        const label = dept.subs[i] || `ROOM ${i + 1}`;
        const tex = plaqueTex(label);
        const plaque = new THREE.Mesh(
          new THREE.PlaneGeometry(0.82, 0.30),
          new THREE.MeshStandardMaterial({ map: tex, roughness: 0.65, metalness: 0.0 })
        );
        plaque.position.set(doorX + Math.cos(rotY) * 0.10, 1.22, z - Math.sin(rotY) * 0.10);
        plaque.rotation.y = rotY;
        world.add(plaque);
      }
      
      // Build orientation room copy at hallway end (these create the infinite loop illusion)
      const orientCopyZ = endZ + ORIENT.d/2; // Center of orientation copy
      buildOrientationRoom(orientCopyZ, true, true, false); // isMainRoom=false

      // Mark where this hallway ends (trigger for completion tracking)
      const trigger = new THREE.Box3(
        new THREE.Vector3(hallX - HALL.w/2 + 0.4, 0, endZ - 2.2),
        new THREE.Vector3(hallX + HALL.w/2 - 0.4, 2.0, endZ - 0.2)
      );
      hallwayInfo.push({ deptKey: dept.key, hallX, startZ, endZ, trigger, orientCopyZ });
    }

    // ---- Massive Chamber ----
    const CHAMBER_D = 26; // Chamber depth
    let chamberBuilt = false;
    let centerAccentWall = null; // Store reference for highlighting on completion

    function buildMassiveChamber(){
      if (chamberBuilt) return;
      chamberBuilt = true;

      // Chamber starts AFTER the orientation room copies at the hallway ends
      const chamberStartZ = ORIENT.z + ORIENT.d/2 + HALL.len + ORIENT.d; // After hallway ends + orientation copy
      const chamberW = 40;
      const chamberD = CHAMBER_D;
      const chamberH = 3.2; // taller than hallways for dramatic effect
      const chamberCenterZ = chamberStartZ + chamberD/2;

      // Floor and ceiling
      floorPlane(0, chamberCenterZ, chamberW, chamberD, mat.offWhite);
      ceilPlane(0, chamberCenterZ, chamberW, chamberD, chamberH, mat.ceiling);

      const cy = chamberH/2;

      // Back wall with three hallway openings
      const backZ = chamberStartZ + chamberD;
      const openingW = HALL.w + 0.2; // Slightly wider than hallway
      
      // Left section (before COMPLIANCE opening)
      const leftStart = -chamberW/2;
      const leftEnd = HALL_X.COMPLIANCE - openingW/2;
      if (leftEnd - leftStart > 0.25) {
        wallBox((leftStart + leftEnd)/2, cy, backZ, leftEnd - leftStart, chamberH, WALL_T, mat.offWhite);
      }
      
      // Middle-left section (between COMPLIANCE and SURVEILLANCE)
      const midLeft1Start = HALL_X.COMPLIANCE + openingW/2;
      const midLeft1End = HALL_X.SURVEILLANCE - openingW/2;
      if (midLeft1End - midLeft1Start > 0.25) {
        wallBox((midLeft1Start + midLeft1End)/2, cy, backZ, midLeft1End - midLeft1Start, chamberH, WALL_T, mat.offWhite);
      }
      
      // Middle-right section (between SURVEILLANCE and PURSUANCE)
      const midRight1Start = HALL_X.SURVEILLANCE + openingW/2;
      const midRight1End = HALL_X.PURSUANCE - openingW/2;
      if (midRight1End - midRight1Start > 0.25) {
        wallBox((midRight1Start + midRight1End)/2, cy, backZ, midRight1End - midRight1Start, chamberH, WALL_T, mat.offWhite);
      }
      
      // Right section (after PURSUANCE opening)
      const rightStart = HALL_X.PURSUANCE + openingW/2;
      const rightEnd = chamberW/2;
      if (rightEnd - rightStart > 0.25) {
        wallBox((rightStart + rightEnd)/2, cy, backZ, rightEnd - rightStart, chamberH, WALL_T, mat.offWhite);
      }

      // Side walls
      wallBox(-chamberW/2, cy, chamberCenterZ, WALL_T, chamberH, chamberD, mat.offWhite);
      wallBox(chamberW/2, cy, chamberCenterZ, WALL_T, chamberH, chamberD, mat.offWhite);

      // Visual references to the three departments - colored accent walls on back wall
      // COMPLIANCE (left) - green
      const leftAccentW = 8;
      const leftAccent = new THREE.Mesh(
        new THREE.BoxGeometry(leftAccentW, chamberH * 0.6, 0.08),
        mat.green
      );
      leftAccent.position.set(HALL_X.COMPLIANCE, chamberH * 0.5, backZ - 0.12);
      world.add(leftAccent);

      // SURVEILLANCE (center) - charcoal
      const centerAccentW = 10;
      centerAccentWall = new THREE.Mesh(
        new THREE.BoxGeometry(centerAccentW, chamberH * 0.6, 0.08),
        mat.charcoal
      );
      centerAccentWall.position.set(HALL_X.SURVEILLANCE, chamberH * 0.5, backZ - 0.12);
      world.add(centerAccentWall);

      // PURSUANCE (right) - navy
      const rightAccentW = 8;
      const rightAccent = new THREE.Mesh(
        new THREE.BoxGeometry(rightAccentW, chamberH * 0.6, 0.08),
        mat.navy
      );
      rightAccent.position.set(HALL_X.PURSUANCE, chamberH * 0.5, backZ - 0.12);
      world.add(rightAccent);

      // Department labels on the accent walls
      addHeaderSign('COMPLIANCE', HALL_X.COMPLIANCE, backZ - 0.35);
      addHeaderSign('SURVEILLANCE', HALL_X.SURVEILLANCE, backZ - 0.35);
      addHeaderSign('PURSUANCE', HALL_X.PURSUANCE, backZ - 0.35);

      // Chamber lighting - more dramatic
      for(let i=0; i<6; i++){
        const x = -15 + i * 6;
        const z = chamberCenterZ;
        const panel = new THREE.Mesh(
          new THREE.BoxGeometry(3.5, 0.06, 1.2),
          new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.25,
            metalness: 0.0,
            emissive: 0xffffff,
            emissiveIntensity: 0.32
          })
        );
        panel.position.set(x, chamberH - 0.20, z);
        world.add(panel);

        const light = new THREE.PointLight(0xffffff, 0.45, 28, 1.4);
        light.position.set(x, chamberH - 0.50, z);
        scene.add(light);
      }

      // Transition markers at each hallway entrance to the chamber
      const transitionZ = chamberStartZ - 0.5;
      
      // Left hallway transition (COMPLIANCE - green)
      const leftTrans = new THREE.Mesh(
        new THREE.BoxGeometry(HALL.w - 0.4, 0.08, 1.0),
        mat.green
      );
      leftTrans.position.set(HALL_X.COMPLIANCE, 0.04, transitionZ);
      world.add(leftTrans);

      // Center hallway transition (SURVEILLANCE - charcoal)
      const centerTrans = new THREE.Mesh(
        new THREE.BoxGeometry(HALL.w - 0.4, 0.08, 1.0),
        mat.charcoal
      );
      centerTrans.position.set(HALL_X.SURVEILLANCE, 0.04, transitionZ);
      world.add(centerTrans);

      // Right hallway transition (PURSUANCE - navy)
      const rightTrans = new THREE.Mesh(
        new THREE.BoxGeometry(HALL.w - 0.4, 0.08, 1.0),
        mat.navy
      );
      rightTrans.position.set(HALL_X.PURSUANCE, 0.04, transitionZ);
      world.add(rightTrans);
    }

    // ---- Counter Program door group ----
    const cpGroup=new THREE.Group();
    scene.add(cpGroup);
    cpGroup.visible=false;
    const cp={ trigger:null, hallKey:null, logo:null, neon:null };

    function buildCPAt(hall){
      cpGroup.clear();
      const x=hall.hallX;
      const z=hall.endZ-0.55;
      const door=new THREE.Mesh(new THREE.BoxGeometry(1.1,1.6,0.10), mat.trim);
      door.position.set(x,0.80,z);
      cpGroup.add(door);
      addCollider(door);

      const logoMat=new THREE.MeshStandardMaterial({ color:0xffffff, transparent:true, roughness:0.25, metalness:0.0, emissive:new THREE.Color(0xffffff), emissiveIntensity:1.25, toneMapped:false });
      const logo=new THREE.Mesh(new THREE.PlaneGeometry(2.4,1.9), logoMat);
      logo.position.set(x,1.42,z-0.08);
      logo.rotation.y=Math.PI;
      cpGroup.add(logo);
      cp.logo=logo;

      new THREE.TextureLoader().load('./Eye-White_Transparent.png', (tex)=>{
        tex.colorSpace=THREE.SRGBColorSpace;
        logoMat.map=tex;
        logoMat.needsUpdate=true;
      });

      const neon=new THREE.PointLight(0xffffff,0.80,9,2.0);
      neon.position.set(x,1.42,z-0.55);
      cpGroup.add(neon);
      cp.neon=neon;

      cp.trigger=new THREE.Box3(
        new THREE.Vector3(x-1.4,0,z-1.6),
        new THREE.Vector3(x+1.4,2.0,z+0.6)
      );
    }

    function updateCP(){
      if (exploreOnly || cpDisabled){ cpGroup.visible=false; return; }
      cpGroup.visible = allComplete();
      if (!cpGroup.visible) return;
      const hall=hallwayInfo.find(h=>h.deptKey=== (cp.hallKey||'SURVEILLANCE')) || hallwayInfo[1];
      buildCPAt(hall);
    }

    // ---- Build world ----
    buildElevatorTransition(); // Corridor from elevator to orientation room
    buildOrientationRoom(); // Build main orientation room
    for(const d of deptList) buildHallway(d);
    buildElevator();
    // Don't build chamber yet - it should only appear after all 3 departments visited
    updateCP();

    // ---- Input / pointer lock ----
    statusEl.textContent='READY';

    let yaw = Math.PI; // face elevator doors
    let pitch = 0;

    // Smooth mouse look targets
    let yawTarget = yaw;
    let pitchTarget = pitch;
    const MOUSE_SENS = 0.0019;     // smaller = slower
    const LOOK_SMOOTH = 8;         // bigger = snappier (8 provides smooth mouse feel)

    function onMouseMove(e){
      yawTarget   -= (e.movementX || 0) * MOUSE_SENS;
      // Invert Y so mouse-up looks up (not down)
      pitchTarget += (e.movementY || 0) * MOUSE_SENS;
      const lim = Math.PI/2 - 0.02;
      pitchTarget = Math.max(-lim, Math.min(lim, pitchTarget));
    }

    function requestLock(){
      overlay.style.display='none';
      enterMsg.style.display='none';
      renderer.domElement.requestPointerLock?.();
      if(!document.__rbMouseAttached){
        document.addEventListener('mousemove', onMouseMove);
        document.__rbMouseAttached=true;
      }
      if (isInElevator(camera.position) && !elev.open) openElevator();
    }
    window.__rbEnter = requestLock;

    document.addEventListener('pointerlockchange', ()=>{
      const locked=(document.pointerLockElement===renderer.domElement);
      if(locked){
        overlay.style.display='none';
        if(!document.__rbMouseAttached){
          document.addEventListener('mousemove', onMouseMove);
          document.__rbMouseAttached=true;
        }
      }
    });

    // Keys (use e.code for consistent controls)
    const keys = new Set();
    let crouchToggle = false;
    let crouchHold = false;

    function openElevator(){
      if (elev.open) return;
      elev.open = true;
      elev.t = 0;
      if (elev.leftColl)  elev.leftColl.active  = false;
      if (elev.rightColl) elev.rightColl.active = false;
    }

    window.addEventListener('keydown', (e) => {
      const k = e.code; // KeyW, KeyA, ShiftLeft, ControlLeft, Enter...
      keys.add(k);

      // Crouch controls ONLY while inside elevator
      if (k === 'KeyC' && !e.repeat && isInElevator(camera.position)) {
        crouchToggle = !crouchToggle;
      }
      if ((k === 'ControlLeft' || k === 'ControlRight') && isInElevator(camera.position)) {
        crouchHold = true;
      }

      // Elevator door open
      if (k === 'Enter' && isInElevator(camera.position)) {
        openElevator();
      }

      // Door interaction
      if (k === 'KeyF' && !e.repeat) {
        const d = lookDoor(2.2);
        if (d) toggleDoor(d);
      }

      // Exit / Counter Program
      if (k === 'KeyE' && !e.repeat) {
        if (cpGroup.visible && cp.trigger && cp.trigger.containsPoint(camera.position)) showCPOverlay();
      }
    });

    window.addEventListener('keyup', (e) => {
      const k = e.code;
      keys.delete(k);
      if (k === 'ControlLeft' || k === 'ControlRight') crouchHold = false;
    });

    // ---- CP Overlay wiring ----
    const cpOverlay=document.getElementById('cpOverlay');
    const cpActions=document.getElementById('cpActions');
    const afterJoin=document.getElementById('afterJoin');
    const phoneEl=document.getElementById('phone');
    const submitBtn=document.getElementById('submitPhone');
    const cancelBtn=document.getElementById('cpCancel');
    const exploreBtn=document.getElementById('explore');
    const listenBtn=document.getElementById('listen');
    const cpErr=document.getElementById('cpErr');

    function showCPOverlay(){
      cpOverlay.style.display='flex';
      cpOverlay.setAttribute('aria-hidden','false');
      cpActions.style.display='flex';
      afterJoin.style.display='none';
      cpErr.style.display='none';
      cpErr.textContent='';
      phoneEl.value='';
      if(document.pointerLockElement) document.exitPointerLock();
      setTimeout(()=>phoneEl.focus(), 30);
    }
    function hideCPOverlay(){
      cpOverlay.style.display='none';
      cpOverlay.setAttribute('aria-hidden','true');
      setTimeout(()=>renderer.domElement.requestPointerLock?.(), 30);
    }

    function normalizePhone(raw){
      const digits=(raw||'').replace(/\D/g,'');
      return (digits.length>=10) ? { ok:true, digits } : { ok:false, digits };
    }

    submitBtn.addEventListener('click', ()=>{
      const phone=phoneEl.value.trim();
      const {ok,digits}=normalizePhone(phone);
      if(!ok){ cpErr.style.display='block'; cpErr.textContent='PLEASE ENTER A VALID PHONE NUMBER.'; return; }
      cpErr.style.display='none';
      const leads=JSON.parse(localStorage.getItem('rb_leads')||'[]');
      leads.push({ phone, digits, ts:new Date().toISOString() });
      localStorage.setItem('rb_leads', JSON.stringify(leads));
      cpActions.style.display='none';
      afterJoin.style.display='flex';
    });

    cancelBtn.addEventListener('click', hideCPOverlay);
    exploreBtn.addEventListener('click', ()=>{
      sessionStorage.setItem('rb_explore_only','1');
      sessionStorage.setItem('rb_disable_cp','1');
      localStorage.removeItem('rb_completed');
      location.href = location.pathname + '?explore=1&reset=1';
    });
    listenBtn.addEventListener('click', ()=>window.open('https://reallybadband.komi.io','_blank','noopener'));

    // ---- Spawn (standing) ----
    camera.position.set(ELEV.x, STAND_Y, ELEV.z-0.20);

    // ---- Movement ----
    const vel=new THREE.Vector3();
    const wish=new THREE.Vector3();

function applyStance(){
  const inElev = isInElevator(camera.position);
  const nearElevExit = camera.position.z > ELEV.z && camera.position.z < ELEV.z + 8;
  const wantCrouch = (inElev || nearElevExit) ? (crouchHold || crouchToggle) : false;

      // You can toggle/hold crouch ONLY in the elevator, but once you enter the crawl tunnel
      // we force crouch so you don’t snap-stand the instant you step out of the elevator.

      if(wantCrouch){
        camera.position.y = CROUCH_Y;
        PLAYER_HALF_H = 0.18;
      } else {
        camera.position.y = STAND_Y;
        PLAYER_HALF_H = 0.25;
      }
    }

    function tryMove(dx,dz){
      const px=camera.position.x, py=camera.position.y, pz=camera.position.z;
      if(!collides(px+dx,py,pz)) camera.position.x+=dx;
      if(!collides(camera.position.x,py,pz+dz)) camera.position.z+=dz;
    }

    // ---- Elevator doors animate ----
    function updateElevDoors(dt){
      if(!elev.open || !elev.left || !elev.right) return;
      elev.t=Math.min(1, elev.t+dt*1.2);
      const openAmt=elev.t;
      const hatchW=1.55;
      elev.left.position.x  = ELEV.x - hatchW/4 - openAmt*(hatchW*0.30);
      elev.right.position.x = ELEV.x + hatchW/4 + openAmt*(hatchW*0.30);
    }

     // ---- Hall completion tracking ----
    let completionTriggered = false;
    let lastTriggeredHall = null;
    
    function handleLoops(){
      let triggerActive = false;
      
      for(const h of hallwayInfo){
        if(h.trigger.containsPoint(camera.position)){
          triggerActive = true;
          
          // Prevent multiple triggers on same hallway
          if (lastTriggeredHall === h.deptKey) return;
          lastTriggeredHall = h.deptKey;
          
          // Mark department as visited if not already
          if (!completed.has(h.deptKey)){
            completed.add(h.deptKey);
            saveCompletion();
            cp.hallKey = h.deptKey;
            updateCP();
          }
          
          // Check if all 3 departments are complete
          if(completed.size === 3 && !completionTriggered){
            completionTriggered = true;
            
            // Build the massive chamber (it appears beyond the orientation copies)
            buildMassiveChamber();
            
            // Highlight center accent wall to draw attention
            if (centerAccentWall && centerAccentWall.material) {
              centerAccentWall.material.emissive = new THREE.Color(0x5e5a54);
              centerAccentWall.material.emissiveIntensity = 0.65;
            }
          }
          
          // No teleportation - player walks naturally through orientation copies
          // The copies create the infinite loop illusion by showing C/S/P hallways again
          
          return;
        }
      }
      
      // Reset trigger only if player has left ALL trigger zones
      if (!triggerActive) {
        lastTriggeredHall = null;
      }
    }
    // ---- CP shimmer ----
    function updateCPGlow(t){
      if(!cpGroup.visible || !cp.neon) return;
      const s=0.65+0.20*Math.sin(t*2.2)+0.08*Math.sin(t*10.0);
      cp.neon.intensity=0.75*s;
      if(cp.logo && cp.logo.material) cp.logo.material.emissiveIntensity=1.0+0.45*s;
    }

    // ---- Loop ----
    let last=performance.now();
    function tick(now){
      const dt=Math.min(0.033,(now-last)/1000);
      last=now;

      applyStance();

      // smooth look (lerp toward targets)
      const lookLerp = 1 - Math.exp(-LOOK_SMOOTH * dt);
      yaw   += (yawTarget - yaw) * lookLerp;
      pitch += (pitchTarget - pitch) * lookLerp;

      // movement (FPS-style)
      wish.set(0,0,0);
      // Three.js camera forward is -Z when yaw=0, so forward must be (-sin, 0, -cos)
      const f = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
      const r = new THREE.Vector3( Math.cos(yaw), 0, -Math.sin(yaw));

      if (keys.has('KeyW')) wish.add(f);
      if (keys.has('KeyS')) wish.addScaledVector(f, -1);
      if (keys.has('KeyD')) wish.add(r);
      if (keys.has('KeyA')) wish.addScaledVector(r, -1);

      if (wish.lengthSq() > 0) wish.normalize();

      const sprinting = keys.has('ShiftLeft') || keys.has('ShiftRight');
      const maxSpd = sprinting ? SPRINT : WALK;

      // make movement feel tighter / less floaty
      const accel = 40.0;
      const damp  = 28.0;

      const tx = wish.x * maxSpd;
      const tz = wish.z * maxSpd;
      vel.x += (tx - vel.x) * Math.min(1, accel * dt);
      vel.z += (tz - vel.z) * Math.min(1, accel * dt);

      if (wish.lengthSq() === 0) {
        const d = Math.max(0, 1 - damp * dt);
        vel.x *= d;
        vel.z *= d;
      }

      tryMove(vel.x * dt, vel.z * dt);

      // Apply world bounds
      camera.position.x=Math.max(BOUNDS_X_MIN,Math.min(BOUNDS_X_MAX,camera.position.x));
      camera.position.z=Math.max(BOUNDS_Z_MIN,Math.min(BOUNDS_Z_MAX,camera.position.z));

      updateElevDoors(dt);
      if (typeof elev.drawIndicator === 'function') elev.drawIndicator(now);
      handleLoops();
      updateCPGlow(now/1000);

      camera.rotation.set(pitch,yaw,0);
      renderer.render(scene,camera);
      requestAnimationFrame(tick);
    }

    // Start anim
    requestAnimationFrame(tick);

    // resize
    window.addEventListener('resize',()=>{
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });

  })();
  </script>
</body>
</html>